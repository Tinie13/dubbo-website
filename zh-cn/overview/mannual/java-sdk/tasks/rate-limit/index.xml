<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 限流降级</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/</link><description>Recent content in 限流降级 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: 使用 Sentinel 应对突发流量，保护您的应用</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/sentinel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/sentinel/</guid><description>
&lt;p>在复杂的生产环境下可能部署着成千上万的 Dubbo 服务实例，流量持续不断地进入，服务之间进行相互调用。但是分布式系统中可能会因流量激增、系统负载过高、网络延迟等一系列问题，导致某些服务不可用，如果不进行相应的控制可能导致级联故障，影响服务的可用性，因此如何对流量进行合理的控制，成为保障服务稳定性的关键。&lt;/p>
&lt;p>&lt;a href="https://github.com/alibaba/Sentinel">Sentinel&lt;/a> 是阿里中间件团队开源的，面向分布式服务架构的轻量级流量控制产品，主要以流量为切入点，从&lt;strong>流量控制&lt;/strong>、&lt;strong>熔断降级&lt;/strong>、&lt;strong>系统负载保护&lt;/strong>等多个维度来帮助用户保护服务的稳定性。&lt;/p>
&lt;p>本文提供 Dubbo 整合 Sentinel 限流降级的最佳实践。&lt;/p>
&lt;h2 id="快速接入-sentinel">快速接入 Sentinel&lt;/h2>
&lt;p>Sentinel 通过对服务提供方和服务消费方的限流提升服务在极端场景下的可用性，接下来我们看看 Sentinel 对服务提供方和服务消费方限流的技术实现方式。&lt;/p>
&lt;p>使用时我们只需引入以下模块（以 Maven 为例）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba.csp&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>sentinel-apache-dubbo3-adapter&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>1.8.6&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">&amp;lt;!-- optional --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba.csp&lt;span style="color:#268bd2">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;artifactId&amp;gt;&lt;/span>sentinel-transport-simple-http&lt;span style="color:#268bd2">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;version&amp;gt;&lt;/span>1.8.6&lt;span style="color:#268bd2">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>sentinel-apache-dubbo3-adapter&lt;/code> 中包含 Sentinel Filter 实现，加入依赖之后会自动开启。如若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可通过配置关闭，如 &lt;code>dubbo.provider.filter=&amp;quot;-sentinel.dubbo.consumer.filter&amp;quot;&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="示例详解">示例详解&lt;/h2>
&lt;p>可在此查看以下 &lt;a href="https://github.com/apache/dubbo-samples/tree/master/4-governance/dubbo-samples-sentinel">示例的完整源码&lt;/a>。&lt;/p>
&lt;h3 id="provider-端限流">Provider 端限流&lt;/h3>
&lt;p>对服务提供方的流量控制可分为 &lt;strong>服务提供方的自我保护能力&lt;/strong> 和 &lt;strong>服务提供方对服务消费方的请求分配能力&lt;/strong> 两个维度。&lt;/p>
&lt;h4 id="基于-qps-设定限流">基于 QPS 设定限流&lt;/h4>
&lt;p>为了保护 Provider 不被激增的流量拖垮影响稳定性，可以给 Provider 配置 &lt;strong>QPS 模式&lt;/strong> 的限流，这样当每秒的请求量超过设定的阈值时会自动拒绝多出来的请求。&lt;/p>
&lt;p>以下是示例中配置的 &lt;strong>服务级别&lt;/strong> 的 QPS 限流配置，最大 QPS 设定为 10：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Limit DemoService to 10 QPS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRule flowRule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FlowRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Note: the resource name here is the interface name.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setResource(DemoService.class.getName());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setCount(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setLimitApp(&lt;span style="color:#2aa198">&amp;#34;default&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRuleManager.loadRules(Collections.singletonList(flowRule));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下是示例中配置的 &lt;strong>方法级别&lt;/strong> 的 QPS 限流配置，最大 QPS 设定为 5：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Limit sayHelloAgain method to 10 QPS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRule flowRule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FlowRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Note: the resource name here includes the method signature.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setResource(DemoService.class.getName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;:sayHelloAgain(java.lang.String)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setCount(5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setLimitApp(&lt;span style="color:#2aa198">&amp;#34;default&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRuleManager.loadRules(Collections.singletonList(flowRule));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动消费端进程并持续发起调用，以下是限流生效后 provider 端打印的日志：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>2018-07-24 17:13:43|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,|5,0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Provider 对应的 metrics 日志中也有记录：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService|15|0|15|0|3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1532423623000|2018-07-24 17:13:43|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String)|10|5|10|0|0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="基于-qps-限流针对特定消费者">基于 QPS 限流(针对特定消费者)&lt;/h4>
&lt;p>上一节中的 QPS 限流值是针对所有消费端流量的，你也可以对来自特定消费端（以 dubbo 应用名识别）的 QPS 进行限流，通过设置 &lt;code>flowRule.setLimitApp(&amp;quot;sentinel-consumer&amp;quot;);&lt;/code> 即可，其中 &lt;code>sentinel-consumer&lt;/code> 为发起调用的消费端应用名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">//......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// Note: this will take effect only for the specific consumer whose app name is &amp;#34;sentinel-consumer&amp;#34;.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setLimitApp(&lt;span style="color:#2aa198">&amp;#34;sentinel-consumer&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setGrade(RuleConstant.FLOW_GRADE_QPS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRuleManager.loadRules(Collections.singletonList(flowRule));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在限流日志中会也会记录调用方的名称，如下面的日志中的 &lt;code>sentinel-consumer&lt;/code> 即为调用方名称：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-fallback" data-lang="fallback">&lt;span style="display:flex;">&lt;span>2018-07-25 16:26:48|1|com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String),FlowException,default,demo-consumer|5,0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意：为了使 &lt;code>limitApp&lt;/code> 生效，开发者需要调用调用 &lt;code>RpcContext.getContext.setAttachment(&amp;quot;dubboApplication&amp;quot;, &amp;quot;sentinel-consumer&amp;quot;)&lt;/code> 标识自己的身份，如果消费端引入了 &lt;code>sentinel-apache-dubbo3-adapter&lt;/code> 则不需要额外调用以上方法了。&lt;/p>
&lt;/blockquote>
&lt;h4 id="设置限流发生后执行的方法">设置限流发生后执行的方法&lt;/h4>
&lt;p>调用 &lt;code>DubboAdapterGlobalConfig.setProviderFallback()&lt;/code> 可以设置限流发生后的方法回调，这样就能在限流后做更多的定制动作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>DubboAdapterGlobalConfig.setProviderFallback((invoker, invocation, ex) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(&lt;span style="color:#2aa198">&amp;#34;Blocked by Sentinel: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> ex.getClass().getSimpleName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> invocation);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> AsyncRpcResult.newDefaultAsyncResult(ex.toRuntimeException(), invocation);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consumer-端限流">Consumer 端限流&lt;/h3>
&lt;p>对服务消费方的流量控制可分为 &lt;strong>控制并发线程数&lt;/strong> 和 &lt;strong>服务降级&lt;/strong> 两个维度。&lt;/p>
&lt;h4 id="并发线程数限流">并发线程数限流&lt;/h4>
&lt;p>推荐给 Consumer 配置&lt;strong>线程数模式&lt;/strong>限流，来保证自身不被不稳定服务所影响。采用基于线程数的限流模式后，我们不需要再显式地去进行线程池隔离，Sentinel 会控制资源的线程数，超出的请求直接拒绝，直到堆积的线程处理完成，可以达到&lt;strong>信号量隔离&lt;/strong>的效果。&lt;/p>
&lt;p>以下方法设置消费端的最大并发线程数，方法 &lt;code>sayHelloConsumerFlowControl&lt;/code> 的并发调用在超过 3 个线程时就会发生限流：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>FlowRule flowRule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> FlowRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setResource(&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.samples.sentinel.DemoService:sayHelloConsumerFlowControl(java.lang.String)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setCount(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flowRule.setGrade(RuleConstant.FLOW_GRADE_THREAD);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FlowRuleManager.loadRules(Collections.singletonList(flowRule));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过调用以下方法，可以设置限流发生时的回调方法（可选）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>DubboAdapterGlobalConfig.setConsumerFallback((invoker, invocation, ex) &lt;span style="color:#719e07">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(&lt;span style="color:#2aa198">&amp;#34;Blocked by Sentinel: &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> ex.getClass().getSimpleName() &lt;span style="color:#719e07">+&lt;/span> &lt;span style="color:#2aa198">&amp;#34;, &amp;#34;&lt;/span> &lt;span style="color:#719e07">+&lt;/span> invocation);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> AsyncRpcResult.newDefaultAsyncResult(ex.toRuntimeException(), invocation);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="服务熔断降级">服务熔断降级&lt;/h4>
&lt;p>当服务依赖于多个下游服务，而某个下游服务调用非常慢时，会严重影响当前服务的调用。这里我们可以利用 Sentinel 熔断降级的功能，为调用端配置基于平均 RT 的&lt;a href="https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7">降级规则&lt;/a>。这样当调用链路中某个服务调用的平均 RT 升高，在一定的次数内超过配置的 RT 阈值，Sentinel 就会对此调用资源进行降级操作，接下来的调用都会立刻拒绝，直到过了一段设定的时间后才恢复，从而保护服务不被调用端短板所影响。同时可以配合 fallback 功能使用，在被降级的时候提供相应的处理逻辑。&lt;/p>
&lt;p>以下方法设置 &lt;code>sayHelloConsumerDowngrade&lt;/code> 的降级策略，当接口调用失败率达到 70% 时，方法调用自动降级：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">static&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">SentinelDowngradeConfig&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> CommandLineRunner {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">run&lt;/span>(String... args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>DegradeRule&lt;span style="color:#719e07">&amp;gt;&lt;/span> rules &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ArrayList&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DegradeRule rule &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> DegradeRule();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setResource(&lt;span style="color:#2aa198">&amp;#34;org.apache.dubbo.samples.sentinel.DemoService:sayHelloConsumerDowngrade(java.lang.String)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setCount(0.7); &lt;span style="color:#586e75">// Threshold is 70% error ratio&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setMinRequestAmount(100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setStatIntervalMs(30000); &lt;span style="color:#586e75">// 30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rule.setTimeWindow(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rules.add(rule);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DegradeRuleManager.loadRules(rules);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="sentinel控制台">Sentinel控制台&lt;/h2>
&lt;p>Sentinel 的控制台可以作为流量控制、熔断降级规则统一配置和管理的入口，同时它为用户提供了多个维度的监控功能。在 Sentinel 控制台上：&lt;/p>
&lt;ul>
&lt;li>动态下发配置规则并实时查看流量控制效果&lt;/li>
&lt;li>查看机器列表以及健康情况&lt;/li>
&lt;/ul>
&lt;h3 id="应用如何接入控制台">应用如何接入控制台&lt;/h3>
&lt;p>接入 Sentinel 控制台的步骤如下（&lt;strong>缺一不可&lt;/strong>）：&lt;/p>
&lt;ol>
&lt;li>按照 &lt;a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0">Sentinel 控制台文档&lt;/a> 启动控制台&lt;/li>
&lt;li>应用引入 &lt;code>sentinel-transport-simple-http&lt;/code> 依赖，以便控制台可以拉取对应应用的相关信息&lt;/li>
&lt;li>给应用添加相关的启动参数，启动应用。需要配置的参数有：
&lt;ul>
&lt;li>&lt;code>-Dcsp.sentinel.api.port&lt;/code>：客户端的 port，用于上报相关信息（默认为 8719）&lt;/li>
&lt;li>&lt;code>-Dcsp.sentinel.dashboard.server&lt;/code>：控制台的地址&lt;/li>
&lt;li>&lt;code>-Dproject.name&lt;/code>：应用名称，会在控制台中显示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>这样在启动应用后就能在控制台找到对应的应用了。&lt;/p>
&lt;h3 id="控制台功能简介">控制台功能简介&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>单台设备监控&lt;/strong>：当在机器列表中看到您的机器，就代表着已经成功接入控制台，可以查看单台设备的设备名称、IP地址、端口号、健康状态和心跳时间等信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/tasks/sentinel/dashboard-1.png" alt="sentinel-dashboard">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>链路监控&lt;/strong>：簇点链路实时的去拉取指定客户端资源的运行情况，它提供了两种展示模式，一种用书状结构展示资源的调用链路；另外一种则不区分调用链路展示资源的运行情况。通过链路监控，可以查看到每个资源的流控和降级的历史状态。&lt;/li>
&lt;/ul>
&lt;p>树状链路&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/tasks/sentinel/dashboard-2.png" alt="sentinel-dashboard">&lt;/p>
&lt;p>平铺链路&lt;/p>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/tasks/sentinel/dashboard-3.png" alt="sentinel-dashboard">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>聚合监控&lt;/strong>：同一个服务下的所有机器的簇点信息会被汇总，实现实时监控，精确度达秒级。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/tasks/sentinel/dashboard-4.png" alt="sentinel-dashboard">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>规则配置&lt;/strong>：可以查看已有的限流、降级和系统保护规则，并实时地进行配置。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://dubbo.apache.org/imgs/v3/tasks/sentinel/dashboard-5.png" alt="sentinel-dashboard">&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;p>关于 Sentinel 的更多使用方式可以参考 &lt;a href="https://sentinelguard.io/zh-cn/index.html">Sentinel 官网&lt;/a>&lt;/p></description></item><item><title>Overview: Dubbo 框架内置的并发控制策略</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/concurrency-control/</guid><description>
&lt;p>Dubbo 通过 Filter 拦截器机制，内置了并发控制策略实现。限制从同一客户端到同一服务的并发请求数，防止恶意请求使服务器过载，确保服务的稳定性，并防止使用过多资源。&lt;/p>
&lt;ul>
&lt;li>控制某些服务的最大并发请求数，确保其他服务的资源可用性。系统过载和确保系统稳定性。&lt;/li>
&lt;li>允许在需求增加时更平滑地扩展服务。&lt;/li>
&lt;li>确保服务在高峰使用时间保持可靠和稳定。&lt;/li>
&lt;/ul>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">注意&lt;/h4>
这种方式要求用户准确的预先评估系统能处理的并发数，而准确的评估系统处理能力并不是一件容易的事情，因此 Dubbo 还提供了自适应限流模式，根据系统负载自动识别系统健康程度并进行限流保护，可以在此查看 &lt;a href="../adaptive-concurrency-control">自适应限流模式使用文档&lt;/a>。
&lt;/div>
&lt;h2 id="限流策略配置">限流策略配置&lt;/h2>
&lt;h3 id="限制服务器端并发执行数服务粒度">限制服务器端并发执行数(服务粒度)&lt;/h3>
&lt;p>限制 &lt;code>com.foo.BarService&lt;/code> 的每个方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个&lt;/p>
&lt;p>XML 方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> executes=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@DubboService&lt;/span>(executes&lt;span style="color:#719e07">=&lt;/span>10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> DemoServiceImpl &lt;span style="color:#268bd2">implements&lt;/span> DemoService{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="限制服务器端并发执行数方法粒度">限制服务器端并发执行数(方法粒度)&lt;/h3>
&lt;p>限制 &lt;code>com.foo.BarService&lt;/code> 的 &lt;code>sayHello&lt;/code> 方法，服务器端并发执行（或占用线程池线程数）不能超过 10 个&lt;/p>
&lt;p>XML 方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;dubbo:method&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span> executes=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/dubbo:service&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@DubboService&lt;/span>(executes&lt;span style="color:#719e07">=&lt;/span>10, methods &lt;span style="color:#719e07">=&lt;/span> {&lt;span style="color:#268bd2">@Method&lt;/span>(name&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>,executes&lt;span style="color:#719e07">=&lt;/span>10)})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> DemoServiceImpl &lt;span style="color:#268bd2">implements&lt;/span> DemoService{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="限制消费端并发调用数服务粒度">限制消费端并发调用数(服务粒度)&lt;/h3>
&lt;p>限制 &lt;code>com.foo.BarService&lt;/code> 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个&lt;/p>
&lt;p>XML 方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> actives=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@DubboReference&lt;/span>(actives&lt;span style="color:#719e07">=&lt;/span>10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> DemoService demoService;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="限制消费端并发调用数方法粒度">限制消费端并发调用数(方法粒度)&lt;/h3>
&lt;p>限制 &lt;code>com.foo.BarService&lt;/code> 的 &lt;code>sayHello&lt;/code> 方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个&lt;/p>
&lt;p>XML 方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span>&lt;span style="color:#268bd2">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">&amp;lt;dubbo:method&lt;/span> name=&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span> actives=&lt;span style="color:#2aa198">&amp;#34;10&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;/dubbo:service&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注解方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@DubboReference&lt;/span>(actives&lt;span style="color:#719e07">=&lt;/span>10, methods &lt;span style="color:#719e07">=&lt;/span> {&lt;span style="color:#268bd2">@Method&lt;/span>(name&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">&amp;#34;sayHello&amp;#34;&lt;/span>,executes&lt;span style="color:#719e07">=&lt;/span>10)})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">private&lt;/span> DemoService demoService;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果提供端 &lt;code>@DubboService&lt;/code> 和消费端 &lt;code>@DubboReference&lt;/code> 都配了 actives，则消费端配置值优先级更高，参见：&lt;a href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/principle/">配置的覆盖策略&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="最小并发数负载均衡">最小并发数负载均衡&lt;/h2>
&lt;p>配置服务的客户端的 &lt;code>loadbalance&lt;/code> 属性为 &lt;code>leastactive&lt;/code>，此 Loadbalance 会调用并发数最小的 Provider（Consumer端并发数）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:reference&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> loadbalance=&lt;span style="color:#2aa198">&amp;#34;leastactive&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>或&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> loadbalance=&lt;span style="color:#2aa198">&amp;#34;leastactive&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Overview: 自适应限流</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/adaptive-concurrency-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/rate-limit/adaptive-concurrency-control/</guid><description>
&lt;p>自适应限流的设计与实现思路请参考 &lt;a href="https://dubbo.apache.org/zh-cn/overview/reference/proposals/heuristic-flow-control/#%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81">Dubbo 自适应限流功能&lt;/a>。自适应限流能够确保分布式系统稳定性和可靠性，例如在服务提供商资源有限且多变的场景下。&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;ul>
&lt;li>服务降级预防：当服务提供者因资源耗尽而性能下降时，使用自适应限流暂时减少其接受的请求数直至恢复正常。&lt;/li>
&lt;li>峰值流量处理：当服务流量突然激增时，自适应流量限制可以通过动态减少接受的请求数量来帮助防止服务过载。&lt;/li>
&lt;li>不可预测流量处理：服务提供商可能会遇到不可预测的流量，第三方应用程序使用服务时可能会偶尔产生流量，自适应流量限制可以根据当前系统负载调整允许的最大并发请求数并防止过载。&lt;/li>
&lt;/ul>
&lt;h2 id="使用方式">使用方式&lt;/h2>
&lt;p>设置方法与静态的最大并发值设置类似，只需在服务端设置 flowcontrol 参数即可，可选值有以下两种：&lt;/p>
&lt;ul>
&lt;li>heuristicSmoothingFlowControl。当服务端收到一个请求时，首先判断CPU的使用率是否超过50%。如果没有超过50%，则接受这个请求进行处理。如果超过50%，说明当前的负载较高，便从 HeuristicSmoothingFlowControl 算法中获得当前的 maxConcurrency 值。如果当前正在处理的请求数量超过了 maxConcurrency，则拒绝该请求。&lt;/li>
&lt;li>autoConcurrencyLimiter。与 HeuristicSmoothingFlowControl 的最大区别是，AutoConcurrencyLimiter 是基于窗口的，每当窗口内积累了一定量的采样数据时，才利用窗口内的数据来更新得到 maxConcurrency，其次，利用exploreRatio来对剩余的容量进行探索。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在确保服务端存在多个节点，并且消费端开启重试策略的前提下，限流功能才能更好的发挥作用。&lt;/p>
&lt;/blockquote>
&lt;h3 id="示例一使用-heuristicsmoothingflowcontrol-自适应限流算法">示例一：使用 heuristicSmoothingFlowControl 自适应限流算法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>dubbo.provider.flowcontrol&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">heuristicSmoothingFlowControl&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:provider&lt;/span> flowcontrol=&lt;span style="color:#2aa198">&amp;#34;heuristicSmoothingFlowControl&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="示例二使用-autoconcurrencylimiter-自适应限流算法">示例二：使用 autoConcurrencyLimiter 自适应限流算法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>dubbo.provider.flowcontrol&lt;span style="color:#719e07">=&lt;/span>&lt;span style="color:#2aa198">autoConcurrencyLimiter&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:provider&lt;/span> flowcontrol=&lt;span style="color:#2aa198">&amp;#34;autoConcurrencyLimiter&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="示例三设置服务粒度的-heuristicsmoothingflowcontrol-自适应限流">示例三：设置服务粒度的 heuristicSmoothingFlowControl 自适应限流&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">&amp;lt;dubbo:service&lt;/span> interface=&lt;span style="color:#2aa198">&amp;#34;com.foo.BarService&amp;#34;&lt;/span> flowcontrol=&lt;span style="color:#2aa198">&amp;#34;heuristicSmoothingFlowControl&amp;#34;&lt;/span> &lt;span style="color:#268bd2">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>