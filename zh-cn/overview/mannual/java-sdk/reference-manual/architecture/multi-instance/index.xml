<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Apache Dubbo – 多实例部署</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/</link><description>Recent content in 多实例部署 on Apache Dubbo</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview: 多实例部署的设计理念</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/multi-instance/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>Java 提供的静态变量（static field）能力可以将持有对象引用的行为绑定到类上面来，这给开发者提供了巨大的便利。注入单例模式、工厂模式等设计模式的实现方案都依赖了静态变量的功能。通过使用静态变量，开发者可以在任何时间、任何地点简单地获取到所需要的对象信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">Test&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">static&lt;/span> Object obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Test.obj &lt;span style="color:#719e07">=&lt;/span> xxx;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在一直以来的 Dubbo 框架开发中，静态变量受到了广泛地应用，诸如使用一个全局共享的 ConfigManager 来存储全局配置信息、ServiceRepository 来存储服务信息，不论从中心化管理配置或者是参数获取的便利性的角度来说，这种设计都是最佳的。在 Dubbo 2.7 以前的所有版本，Dubbo 所需要的运行时配置信息都通过全局静态变量获取，通过 RPC 服务三元组（interface + version + group）的方式进行唯一定位。&lt;/p>
&lt;p>但是随着 Dubbo 用户基数的不断扩大以及在阿里集团内由 Dubbo 作为内核的 HSF3 框架都对原来的这种设计模式提出了挑战。&lt;/p>
&lt;p>对于开源用户，社区收到的诉求主要包括以下几点：&lt;/p>
&lt;ol>
&lt;li>在同一个应用内能够创建多个三元组一样的订阅。这个行为在 Dubbo 2.7 中虽然没有做强限制，但是由于 Dubbo 很多参数是取自全局的，而这个获取的索引使用的就是三元组。如果用户创建了两个三元组一样的订阅，他们的参数会被相互覆盖，地址推送等功能也会收到很大的影响。&lt;/li>
&lt;li>Java 提供了自定义 ClassLoader 的机制可以自定义指定类的加载器来源，但是对于 Dubbo 来说并没有去支持多 ClassLoader 的场景，在动态代理生成和序列化场景下都不支持 ClassLoader 切换的行为。&lt;/li>
&lt;li>Dubbo 众多的测试用例都共享了同一份配置信息，导致在进行单元测试的时候极为容易造成环境污染的问题。&lt;/li>
&lt;/ol>
&lt;p>对于阿里集团内大规模落地来说，我们遇到的问题主要有：&lt;/p>
&lt;ol>
&lt;li>阿里集团内有众多的中间件框架，这些框架提供了各种各样的类加载方式，同时业务方期望在同一应用内的配置等信息是相互隔离的。&lt;/li>
&lt;li>一些业务方的定制逻辑需要支持动态热部署的模式，具体体现在动态对某个虚拟环境进行销毁，这需要 Dubbo 内的生命周期管理更加完善。&lt;/li>
&lt;li>集团内有多个对 Spring 容器进行定制化开发的框架，需要 Dubbo 能够支持多个 Spring Context 独立管理生命周期的场景。&lt;/li>
&lt;/ol>
&lt;p>基于众多的这些原因，在八月初的时候我们决定对 Dubbo 的生命周期进行重构，经过一个月的紧张开发，目前社区版本已经完整支持了多实例化的功能，Dubbo 的生命周期也变得更加清晰。&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;p>整个 Dubbo 多实例的设计我们按照了三层模型来配置，分别是 Framework 框架层、Application 应用层、Module 模块层。
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/209479/1633766738924-498b5ac4-d96b-48f4-a55f-8cc946800bee.png#clientId=uc9c7eb9b-dec6-4&amp;amp;from=paste&amp;amp;height=446&amp;amp;id=ub35f4a80&amp;amp;originHeight=892&amp;amp;originWidth=2366&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=483065&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u01b03e88-733f-422b-94ea-cf45220737c&amp;amp;width=1183" alt="image.png">
基于三层机制，我们可以将 Dubbo 按照一定规则进行隔离：&lt;/p>
&lt;ol>
&lt;li>Framework 与 Framework 之间完全隔离，相当于是使用了两个完全不同的 Dubbo 实例&lt;/li>
&lt;li>Application 与 Application 之间按照应用名进行隔离，但是相互有些地共享 Protocol、Serialization 层，目标是达到在同一个 dubbo 端口（20880）上可以承载多个应用，而每个应用独立上报地址信息。&lt;/li>
&lt;li>Module 与 Module 之间可以由用户自定义进行进行隔离，可以是热部署周期的一个状态、也可以是 Spring Context 的一个 Context。通过 Module，用户可以对 Dubbo 的生命周期粒度进行最小的管理。&lt;/li>
&lt;/ol>
&lt;p>为了实现 Dubbo 多实例化，Dubbo 框架内做的最多的变化是修改掉大部分的从静态变量中获取的参数的逻辑，最明显的逻辑是 Dubbo 内部用于参数传递的 URL 对象带上了 ScopeModel 状态，这个 ScopeModel 对应的就是上面提到的三层模型的具体数据承载对象。&lt;/p>
&lt;h2 id="使用方式">使用方式&lt;/h2>
&lt;p>多实例重构版本之后的 Dubbo 对于大多数用户的使用来说是无感知的，改造后的 DubboBootstrap 已经变成一个独立的启动器，用户可以通过 DubboBootstrap 定制多实例的使用。&lt;/p>
&lt;p>下面是使用多实例的一个简单的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> service &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ServiceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> service.setRef(&lt;span style="color:#719e07">new&lt;/span> DemoServiceImpl());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference1 &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference1.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&lt;/span>DemoService&lt;span style="color:#719e07">&amp;gt;&lt;/span> reference2 &lt;span style="color:#719e07">=&lt;/span> &lt;span style="color:#719e07">new&lt;/span> ReferenceConfig&lt;span style="color:#719e07">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference2.setInterface(DemoService.class);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建一个启动器（自动创建新 ApplicationModel）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap1 &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.newInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 指定应用名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap1.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-app-1&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;nacos://localhost:8848&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建一个模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .newModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 在模块内发布服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .service(service)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .endModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建一个模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .newModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 在模块内订阅服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .reference(reference1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .endModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建一个启动器（自动创建新 ApplicationModel）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DubboBootstrap bootstrap2 &lt;span style="color:#719e07">=&lt;/span> DubboBootstrap.newInstance();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 指定应用名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap2.application(&lt;span style="color:#719e07">new&lt;/span> ApplicationConfig(&lt;span style="color:#2aa198">&amp;#34;dubbo-demo-app-2&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .registry(&lt;span style="color:#719e07">new&lt;/span> RegistryConfig(&lt;span style="color:#2aa198">&amp;#34;nacos://localhost:8848&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 创建一个模块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .newModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 在模块内订阅服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .reference(reference2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .endModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// stub1 与 stub2 是两个独立的订阅，互相隔离&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 订阅的 stub&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DemoService stub1 &lt;span style="color:#719e07">=&lt;/span> reference1.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(stub1.sayHello(&lt;span style="color:#2aa198">&amp;#34;Hello World!&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 订阅的 stub&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DemoService stub2 &lt;span style="color:#719e07">=&lt;/span> reference2.get();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.out.println(stub2.sayHello(&lt;span style="color:#2aa198">&amp;#34;Hello World!&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap1.stop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bootstrap2.stop();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个例子对外发布了一个 DemoService 的服务，由 dubbo-demo-app-1 这个应用提供。同时我们创建了两个订阅，分别是在 dubbo-demo-app-1 应用和 dubbo-demo-app-2 应用中，然后我们去对两个订阅进行调用，得到预期的结果。&lt;/p>
&lt;p>这里需要注意的是虽然两个订阅的服务信息是完全一致的，在多实例化改造后，这两个订阅对于消费端来说是完全隔离的，也就是在最新版本的 Dubbo 中是支持三元组一样的情况下通过变更参数来创建多个订阅的行为的了。&lt;/p></description></item><item><title>Overview: 多实例相关的模型与概念定义</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/model/</guid><description>
&lt;h2 id="dubbo-架构">Dubbo 架构&lt;/h2>
&lt;p>JVM —— 虚拟机层
目的：Dubbo 框架之间完全隔离（端口不能复用）&lt;/p>
&lt;p>Dubbo Framework —— 框架层
目的：将需要全局缓存的进行复用（端口、序列化等）&lt;/p>
&lt;p>Application —— 应用层
目的：隔离应用之间的信息，包括注册中心、配置中心、元数据中心&lt;/p>
&lt;p>Services —— 模块层
目的：提供热加载能力，可以按 ClassLoader、Spring Context 进行隔离上下文&lt;/p>
&lt;h2 id="dubbo-概念对齐">Dubbo 概念对齐&lt;/h2>
&lt;ol>
&lt;li>DubboBoorstrap
&lt;ol>
&lt;li>需要拆分 export/refer services、ServiceInstance、Metadata/Config 等 Client&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ConfigManager
&lt;ol>
&lt;li>需要拆分应用级配置信息、模块级配置信息&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ApplicationModel
&lt;ol>
&lt;li>实际存储应用层信息，持有到 ConfigManager 应用级配置信息的引用&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ConsumerModel
&lt;ol>
&lt;li>实际存储接口信息，由 ModuleModel 持有引用&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ProviderModel
&lt;ol>
&lt;li>实际存储接口信息，由 ModuleModel 持有引用&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ExtensionLoader
&lt;ol>
&lt;li>需要根据不同层级 load 出不同的实例对象&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Registry
&lt;ol>
&lt;li>应用级别共享，需要确保多实例订阅正常（考虑单元化场景）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Router / Filter
&lt;ol>
&lt;li>模块级别共享&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Protocol / Remoting
&lt;ol>
&lt;li>框架级别共享，复用 IO，多应用间贡献&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Metadata&lt;/li>
&lt;li>应用级别共享，考虑应用级服务发现&lt;/li>
&lt;li>QoS&lt;/li>
&lt;li>框架级别共享，与 IO 有关&lt;/li>
&lt;li>Serialization&lt;/li>
&lt;li>框架级别共享，与 IO 有关&lt;/li>
&lt;li>ConfigCenter&lt;/li>
&lt;li>应用级别贡献&lt;/li>
&lt;li>ModuleModel（新）&lt;/li>
&lt;li>实际存储模块层信息，持有接口级信息&lt;/li>
&lt;li>FrameworkModel（新）&lt;/li>
&lt;li>实际存储框架层信息&lt;/li>
&lt;/ol>
&lt;h2 id="配置存储梳理">配置存储梳理&lt;/h2>
&lt;h3 id="frameworkmodel">FrameworkModel&lt;/h3>
&lt;p>Qos、Protocol、Remoting、Serialization、ExtensionLoader&lt;/p>
&lt;h3 id="applicationmodel">ApplicationModel&lt;/h3>
&lt;p>ConfigManager（应用级）、DubboBootstrap（类 Fluent API）、Registry、Metadata、ServiceInstance、ConfigCenter、ExtensionLoader&lt;/p>
&lt;h3 id="modulemodel">ModuleModel&lt;/h3>
&lt;p>ConsumerModel、ProviderModel、Router、Filter、ExtensionLoader&lt;/p>
&lt;p>&lt;img src="https://intranetproxy.alipay.com/skylark/lark/0/2021/jpeg/15256464/1628824598406-95556f0d-7817-4010-97a7-0f8e84a175cb.jpeg" alt="">&lt;/p>
&lt;h2 id="dubbo-流程梳理">Dubbo 流程梳理&lt;/h2>
&lt;h3 id="model-创建">Model 创建&lt;/h3>
&lt;p>DefaultModel - FrameworkModel、ApplicationModel、ModuleModel&lt;/p>
&lt;ol>
&lt;li>默认 Model 创建时机&lt;/li>
&lt;li>用户自定义的 Model 的创建方式&lt;/li>
&lt;/ol>
&lt;h3 id="消费端初始化">消费端初始化&lt;/h3>
&lt;ol>
&lt;li>消费端通过 ReferenceConfig 作为入口进行初始化配置相关信息，当前配置里面需要添加 ClassLoader 属性，ReferenceConfig 生成 ConsumerModel 注入到 ModuleModel&lt;/li>
&lt;li>组装的 URL 需要包含当前 ConsumerModel、ModuleModel、ApplicationModel、FrameworkModel（需要梳理全链路内 URL 转换逻辑，保证在中间不会被丢弃）&lt;/li>
&lt;li>组装链路上 Registry 为 ApplicationModel 域内的（订阅需要考虑订阅之间互相独立、多注册中心场景） ；Filter、Cluster、LoadBalance 为 ModuleModel 域内的&lt;/li>
&lt;li>Directory 需要持有包括详细信息的 ConsumerURL，序列化层需要传入配置信息&lt;/li>
&lt;li>ModuleModel 内三元组唯一，总是创建出同一个 proxy；ModuleModel 间允许重复三元组，proxy、invoker 均相互独立&lt;/li>
&lt;/ol>
&lt;h3 id="服务端初始化">服务端初始化&lt;/h3>
&lt;ol>
&lt;li>服务端通过 ServiceConfig 作为入口进行初始化配置相关信息，当前配置里面需要添加 ClassLoader 属性，ServiceConfig 生成 ProviderModel 注入到 ModuleModel&lt;/li>
&lt;li>组装的 URL 需要包含当前 ProviderModel、ModuleModel、ApplicationModel、FrameworkModel（需要梳理全链路内 URL 转换逻辑，保证在中间不会被丢弃）&lt;/li>
&lt;li>组装链路上 Registry 为 ApplicationModel 域内的（订阅需要考虑服务之间互相独立、多注册中心场景） ；Filter 为 ModuleModel 域内的&lt;/li>
&lt;li>Protocol 层持有的三元组保证唯一，可以直接找到 ProviderModel（FrameworkModel 域内）&lt;/li>
&lt;/ol>
&lt;h3 id="地址推送流程">地址推送流程&lt;/h3>
&lt;ol>
&lt;li>注册中心监听需要确保三元组重复的订阅都能独立收到通知、相同三元组到注册中心的订阅链接可以进行复用&lt;/li>
&lt;li>注册中心工作在 ApplicationModel 域，通过持有监听列表连接 ModuleModel 层，地址的处理为 ModuleModel 域内操作，如果服用地址通知需要保证通知内容不会被某个订阅所修改&lt;/li>
&lt;li>每份地址通知根据不同 ModuleModel 独立创建 Invoker，Invoker 直接持有 ConsumerModel&lt;/li>
&lt;li>Invoker 的底层 Protocol 层连接复用 TCP 连接&lt;/li>
&lt;/ol>
&lt;h3 id="消费端调用链路">消费端调用链路&lt;/h3>
&lt;ol>
&lt;li>消费端创建 invocation 时需要携带当前 ConsumerModel、ModuleModel、ApplicationModel、FrameworkModel （通过 consumerURL 携带），需要保证调用全链路 consumerURL 不丢失&lt;/li>
&lt;/ol>
&lt;h3 id="服务端调用链路">服务端调用链路&lt;/h3>
&lt;ol>
&lt;li>服务端收到请求后根据三元组定位 ProviderModel 及 invoker，进行反序列化时需要考虑 ClassLoader 切换&lt;/li>
&lt;/ol>
&lt;h3 id="其他流程">其他流程&lt;/h3>
&lt;ol>
&lt;li>销毁流程&lt;/li>
&lt;li>QoS 聚合方式&lt;/li>
&lt;/ol>
&lt;h2 id="代码改动">代码改动&lt;/h2>
&lt;ol>
&lt;li>ExtensionLoader 依赖注入&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ModuleModel.getExtensionFactory().getAdaptiveExtension(Protocol.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.getExtensionFactory().getAdaptiveExtension(Protocol.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FrameworkModel.getExtensionFactory().getAdaptiveExtension(Protocol.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">@SPI&lt;/span>(scope &lt;span style="color:#719e07">=&lt;/span> FRAMEWORK)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">interface&lt;/span> &lt;span style="color:#268bd2">Protocol&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>SPI 依赖注入&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>DubboBootstrap -&amp;gt; 功能拆分（ModuleModel 维护生命周期）&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 创建新应用实例，共享FrameworkModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DubboBootstrap.newInstance(FrameworkModel) &lt;span style="color:#586e75">// SharedFrameworkModel -&amp;gt; NewApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addModule() &lt;span style="color:#586e75">// New ModuleModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addReference(ReferenceConfig) &lt;span style="color:#586e75">// 将服务配置挂到模块下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addReference(ReferenceConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addService(ServiceConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .endModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addReference(ReferenceConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addService(ServiceConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .endModule()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addRegistry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addConfigCenter()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 兼容旧的Bootstrap API，使用默认应用实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DubboBootstrap.getInstance() &lt;span style="color:#586e75">// DefaultFrameworkModel -&amp;gt; DefaultApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addReference(ReferenceConfig) &lt;span style="color:#586e75">// DefaultApplicationModel -&amp;gt; DefaultModuleModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addService(ServiceConfig) &lt;span style="color:#586e75">// DefaultApplicationModel -&amp;gt; DefaultModuleModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setRegistry() &lt;span style="color:#586e75">// DefaultApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 新建应用实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DubboBootstrap.newInstance() &lt;span style="color:#586e75">// DefaultFrameworkModel -&amp;gt; NewApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addReference(ReferenceConfig) &lt;span style="color:#586e75">// NewApplicationModel -&amp;gt; DefaultModuleModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .addService(ServiceConfig) &lt;span style="color:#586e75">// NewApplicationModel -&amp;gt; DefaultModuleModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setRegistry() &lt;span style="color:#586e75">// NewApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .start()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>
&lt;p>RefenceConfig、ServiceConfig&lt;/p>
&lt;ol>
&lt;li>ModuleModel 动态设置&lt;/li>
&lt;li>需要把 ExtensionLoader 初始化的地方下放到 setModuleModel&lt;/li>
&lt;li>consumerUrl 携带 ModuleModel&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>ModuleModel、ApplicationModel、FrameworkModel&lt;/p>
&lt;ol>
&lt;li>ModuleModel -&amp;gt; ConsumerModels、ProviderModels&lt;/li>
&lt;li>ApplicationModel -&amp;gt; ConfigManager（应用级的属性信息）、ModuleModels&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>ConsumerModel、ProviderModel&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册中心需要支持多订阅&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ModuleModel、ApplicationModel、FrameworkModel（ExtensionLoader）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RefenceConfig、ServiceConfig（ConsumerModel、ProviderModel）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ExtensionLoader (Filter 改动)&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Overview: 多实例启动流程与模块依赖关系</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/workflow/</guid><description>
&lt;p>1、应用启动流程
初始化应用配置，启动内部模块，启动其它模块。
应用启动方式包括：DubboBootstrap.start(), ApplicationModel.getDeployer().start()
&lt;img src="https://cdn.nlark.com/yuque/0/2021/svg/2391732/1634895625292-99fdac6f-3371-4147-9ad5-9428296cb083.svg#clientId=u82d0d5c2-bff3-4&amp;amp;from=drop&amp;amp;id=u8db161d3&amp;amp;originHeight=2594&amp;amp;originWidth=1050&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=64242&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u8976fa81-5bc5-469a-ab4a-b4cda12cd6d" alt="Dubbo start process.svg">
2、模块启动流程
上图中从ModuleDeployer.start() 开始，自动初始化应用配置，启动内部模块，然后启动当前模块。
模块启动方式包括：&lt;/p>
&lt;ol>
&lt;li>Spring context 加载dubbo xml配置或者注解&lt;/li>
&lt;li>手工启动模块：ModuleModel.getDeployer().start()&lt;/li>
&lt;/ol>
&lt;p>3、服务接口API方式启动
ServiceConfig.export() 或者 ReferenceConfig.get() 先自动启动module，然后执行export/refer服务接口&lt;/p></description></item><item><title>Overview: 多实例让源码开发更复杂，学习如何正确的扩展 SPI 实现</title><link>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/architecture/multi-instance/develop/</guid><description>
&lt;p>本文对Dubbo 3多实例改造后编码相关变化进行一个简单的总结。&lt;/p>
&lt;h3 id="层次模型">层次模型&lt;/h3>
&lt;p>从只有ApplicationModel，新增 ScopeModel/FrameworkModel/ModuleModel 表达多实例的层次模型。
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630663265196-0c9e3746-3f62-406b-93d6-7d971ee3e96a.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=302&amp;amp;id=udc7e6f69&amp;amp;originHeight=604&amp;amp;originWidth=1378&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=132247&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u06713196-e7be-483c-8762-6bbc756f336&amp;amp;width=689" alt="image.png">
每个ScopeModel实例都会创建并绑定属于自己的重要成员：&lt;/p>
&lt;ul>
&lt;li>ExtensionDirector&lt;/li>
&lt;li>BeanFactory&lt;/li>
&lt;li>ServiceRepository&lt;/li>
&lt;/ul>
&lt;p>ScopeModel 作为最基础的模型，可以在SPI/Bean/URL 等持有和传递。&lt;/p>
&lt;h3 id="spi扩展">SPI扩展&lt;/h3>
&lt;h4 id="extensionscope">ExtensionScope&lt;/h4>
&lt;p>SPI 注解添加scope属性，标记其所属的作用域。
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630664482020-9d35e6de-17f7-4334-8506-3af362c03de0.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=249&amp;amp;id=u6c288d3d&amp;amp;originHeight=498&amp;amp;originWidth=930&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=197493&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u56167d63-ab53-4cdb-bb10-723d0c97663&amp;amp;width=465" alt="image.png">
ExtensionScope 与层次模型对应关系：&lt;/p>
&lt;ul>
&lt;li>FRAMEWORK&lt;/li>
&lt;li>APPLICATION&lt;/li>
&lt;li>MODULE&lt;/li>
&lt;/ul>
&lt;p>�&lt;/p>
&lt;h4 id="extensiondirector">ExtensionDirector&lt;/h4>
&lt;p>新增ExtensionDirector用于实现多层级的spi管理及依赖注入。&lt;/p>
&lt;p>ExtensionDirector spi extension 创建流程如下：
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630664388603-d12d4002-65ea-43b9-b5c9-c0d7204b22b1.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=303&amp;amp;id=uf804edd7&amp;amp;originHeight=606&amp;amp;originWidth=616&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=71595&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u4944881d-0195-4a23-bdfe-346819db997&amp;amp;width=308" alt="image.png">&lt;/p>
&lt;ul>
&lt;li>每个SPI 只能在匹配的Scope的ExtensionDirector上创建，目的是实现层级之间共享实例和正确注入依赖对象。即APPLICATION scope的SPI必定在ApplicationModel绑定的ExtensionDirector上创建，FRAMEWORK scope的SPI必定在FrameworkModel绑定的ExtensionDirector上创建。&lt;/li>
&lt;li>可见性与scope作用范围相关，这里的可见性是是否能直接注入依赖。即FRAMEWORK scope的SPI可以在FRAMEWORK/APPLICATION/MODULE 都可见，而 APPLICATION scope的SPI只能在APPLICATION/MODULE 可见。&lt;/li>
&lt;li>不可见的SPI需要通过上下文来获取，如可以通过URL传递ScopeModel，可以解决在FRAMEWORK spi访问 APPLICATION spi。&lt;/li>
&lt;/ul>
&lt;p>Scope 作用范围如下图：
上层对象可以注入本层及下层的SPI/Bean对象，下层对象不能注入上层的SPI/Bean对象。
&lt;img src="https://cdn.nlark.com/yuque/0/2021/png/2391732/1630665762212-fcc5e99d-2966-46cd-84ae-9257c4a216c9.png#clientId=u53624b84-1e3c-4&amp;amp;from=paste&amp;amp;height=188&amp;amp;id=u6c2bf0b8&amp;amp;originHeight=376&amp;amp;originWidth=1290&amp;amp;originalType=binary&amp;amp;ratio=1&amp;amp;size=68138&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=ub349222b-17af-4734-b744-dfd2f297930&amp;amp;width=645" alt="image.png">&lt;/p>
&lt;h3 id="bean托管">Bean托管&lt;/h3>
&lt;p>新增ScopeBeanFactory用于内部Bean托管，支持在多个不同模块中共享一个实例对象。
ScopeBeanFactory 也支持scope，注入规则与ExtensionDirector相同。
用法请参考：FrameworkStatusReportService、RemoteMetadataServiceImpl、MetadataReportInstance&lt;/p>
&lt;h3 id="servicerepository">ServiceRepository&lt;/h3>
&lt;p>将原来的ServiceRepository拆分为3个类，分别对应3个层次的模型。
FrameworkServiceRepository
�ServiceRepository
ModuleServiceRepository
�
将服务接口信息ProviderModel/ConsumerModel/ServiceDescriptor 注册到ModuleServiceRepository 中，同时在FrameworkServiceRepository 保存一份映射，用于根据请求查找对应的服务接口模型。&lt;/p>
&lt;h3 id="编码变化总结">编码变化总结&lt;/h3>
&lt;h4 id="1如何获取applicationmodel及应用数据">1、如何获取ApplicationModel及应用数据&lt;/h4>
&lt;p>原方法：ApplicationModel 提供了一系列静态方法用于获取共享应用实例的数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ApplicationModel.getConfigManager()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.getEnvironment()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.getServiceRepository()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.getExecutorRepository()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.getName()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新办法：先找到ApplicationModel实例，然后通过实例的方法获取数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 获取默认实例，兼容原来的单应用实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ApplicationModel.defaultModel().getApplicationEnvironment();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 根据Module获取ApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>moduleModel.getApplicationModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 通过URL获取ApplicationModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ScopeModelUtil.getApplicationModel(url.getScopeModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 通过Config配置类获取&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ScopeModelUtil.getApplicationModel(serviceConfig.getScopeModel());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// SPI/Bean 可通过构造函数注入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">ConfigManager&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// SPI/Bean 通过实现ScopeModelAware接口注入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#268bd2">class&lt;/span> &lt;span style="color:#268bd2">DefaultGovernanceRuleRepositoryImpl&lt;/span> &lt;span style="color:#268bd2">implements&lt;/span> GovernanceRuleRepository, ScopeModelAware {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">private&lt;/span> ApplicationModel applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">public&lt;/span> &lt;span style="color:#dc322f">void&lt;/span> &lt;span style="color:#268bd2">setApplicationModel&lt;/span>(ApplicationModel applicationModel) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">this&lt;/span>.applicationModel &lt;span style="color:#719e07">=&lt;/span> applicationModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 枚举FrameworkModel的所有Application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">for&lt;/span> (ApplicationModel applicationModel : frameworkModel.getApplicationModels()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#719e07">&amp;lt;&lt;/span>RegistryProtocolListener&lt;span style="color:#719e07">&amp;gt;&lt;/span> listeners &lt;span style="color:#719e07">=&lt;/span> applicationModel.getExtensionLoader(RegistryProtocolListener.class)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .getLoadedExtensionInstances();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> (CollectionUtils.isNotEmpty(listeners)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> (RegistryProtocolListener listener : listeners) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listener.onDestroy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">// 枚举所有FrameworkModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">for&lt;/span> (FrameworkModel frameworkModel : FrameworkModel.getAllInstances()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destroyProtocols(frameworkModel);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2如何获取spi扩展实例">2、如何获取SPI扩展实例&lt;/h4>
&lt;p>原方法：是通过静态方法 ExtensionLoader.getExtensionLoader() 获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ExtensionLoader.getExtensionLoader(Cluster.class).getExtension(name, wrap);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新方法：通过ScopeModel或者ExtensionDirector获取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>applicationModel.getExtensionLoader(Cluster.class).getExtension(name, wrap);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3如何查找服务模型">3、如何查找服务模型&lt;/h4>
&lt;p>原方法：通过uniqueServiceName来在ServiceRepository 中lookup 服务模型&lt;/p>
&lt;p>新方法：通过URL传递ScopeModel/ServiceModel，请参考RegistryProtocol&lt;/p>
&lt;h4 id="4如何跨模块共享bean实例">4、如何跨模块共享bean实例&lt;/h4>
&lt;p>原方法：通过静态变量保存bean实例&lt;/p>
&lt;p>新方法：通过BeanFactory共享实例&lt;/p>
&lt;h4 id="5常用工具类及处理技巧">5、常用工具类及处理技巧&lt;/h4>
&lt;p>根据ScopeModel获取某个层次的Model，已经做了兼容处理，scopeModel参数为null时返回默认实例：
ScopeModelUtil.getFrameworkMode(scopeModel)
ScopeModelUtil.getApplicationMode(scopeModel)
ScopeModelUtil.getModuleMode(scopeModel)&lt;/p>
&lt;h3 id="需要改造的几种场景">需要改造的几种场景&lt;/h3>
&lt;p>1、ExtensionLoader.getExtensionLoader()
2、Application.defaultModel() 或者其它静态方法
3、在Framework层获取Application层的对象，如在Protocol中处理Application数据，QOS中遍历所有Application数据，请参考RegistryProtocol。
4、在静态方法中访问默认实例的数据
5、静态变量的bean实例、cache
6、SPI接口中静态方法访问数据，可能要拆分为干净的SPI和Bean，请参考FrameworkStatusReportService/FrameworkStatusReporter。
7、可能某些URL还没有改造，需要在创建时设置ServiceModel/ScopeModel&lt;/p></description></item></channel></rss>